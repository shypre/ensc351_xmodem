þ#!/bin/sh
#
# Copyright (c) 1998-2017 VMware, Inc.  All rights reserved.
#
# This script manages the services needed to run VMwa­ýre software

### BEGIN INIT INFO
# Provides: vmware-tools
# Required-Start: $local_fs
# Required-Stop: $local_fs
# X-Start-BeforŽüe: $network
# X-Stop-After: $network
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: VMware Tools serviœe
# @üe: $network
# X-Stop-After: $network
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: VMware Tools service
# @ûDescription: Manages the services needed to run VMware Tools
### END INIT INFO



# BEGINNING_OF_UTIL_DOT_SH
#!/bin/sh
#
# Copyr=úight (c) 2005-2017 VMware, Inc.  All rights reserved.
#
# A few utility functions used by our shell scripts.  Some expeœt the seúight (c) 2005-2017 VMware, Inc.  All rights reserved.
#
# A few utility functions used by our shell scripts.  Some expect the seùttings
# database to already be loaded and evaluated.

vmblockmntpt="/proc/fs/vmblock/mountPoint"
vmblockfusemntpt="/var/run/vmbÃølock-fuse"

have_vgauth=yes
have_caf=yes

vmware_warn_failure() {
  if [ "`type -t 'echo_warning' 2>/dev/null`" = '™unction' ]; "÷then
    echo_warning
  else
    echo -n "$rc_failed"
  fi
}

vmware_failed() {
  if [ "`type -t 'echo_failure' 2>/dev/null`" = ÷then
    echo_warning
  else
    echo -n "$rc_failed"
  fi
}

vmware_failed() {
  if [ "`type -t 'echo_failure' 2>/dev/null`" = 	ö'function' ]; then
    echo_failure
  else
    echo -n "$rc_failed"
  fi
}

vmware_success() {
  if [ "`type -tß'echo_success' 2
õ>/dev/null`" = 'function' ]; then
    echo_success
  else
    echo -n "$rc_done"
  fi
}

# Execute a macro
vmware_exec() {
  loc
õ>/dev/null`" = 'function' ]; then
    echo_success
  else
    echo -n "$rc_done"
  fi
}

# Execute a macro
vmware_exec() {
  locôal msg="$1"  # IN
  local func="$2" # IN
  shift 2

  echo -n '   '"$msg"

  # On Caldera 2.2, SIGHUP is se‘t to all our childreŒôal msg="$1"  # IN
  local func="$2" # IN
  shift 2

  echo -n '   '"$msg"

  # On Caldera 2.2, SIGHUP is sent to all our childreŒôal msg="$1"  # IN
  local func="$2" # IN
  shift 2

  echo -n '   '"$msg"

  # On Caldera 2.2, SIGHUP is sent to all our childreŒón when this script exits
  # I wanted to use shopt -u huponexit instead but their bash version
  # 1.14Ñ7(1) is too old
  #
  # ©òKsh does not recognize the SIG prefix in front of a signal name
  if [ "$VMWARE_DEBUG" = 'yes' ]; then
    (trap '' HUP; "$func"òKsh does not recognize the SIG prefix in front of a signal name
  if [ "$VMWARE_DEBUG" = 'yes' ]; then
    (trap '' HUP; "$func"ñ "$@")
  else
    (trap '' HUP; "$func" "$@") >/dev/null 2>&1
  fi
  if [ "$?" -gt 0 ]; then
    vmˆare_failed
    echo
    retu‹ðrn 1
  fi

  vmware_success
  echo
  return 0
}


# Execute a macro, report warning on failure
vmware_exec_warn() {
  local msg=¸ï"$1"  # IN
  local func="$2" # IN
  shift 2

  echo -n '   '"$msg"

  if [ "$VMWARE_DEBUG" = 'yes' ]; then
    (trap '' HUP; "$fÖï"$1"  # IN
  local func="$2" # IN
  shift 2

  echo -n '   '"$msg"

  if [ "$VMWARE_DEBUG" = 'yšs' ]; then
    (trap '' HUP; "$fÖîunc" "$@")
  else
    (trap '' HUP; "$func" "$@") >/dev/null 2>&1
  fi
  if [ "$?" -gt 0 ]; then
    vmware_warn_failure
    echÔío
    return 1
  fi

  vmware_success
  echo
  return 0
}

# Execute a macro in the background
vmware_bg_exec() {
  local msg="$Sì1"  # IN
  local func="$2" # IN
  shift 2

  if [ "$VMWARE_DEBUG" = 'yes' ]; then
    # Forœe synchronism when debugging
    vmw•ëare_exec "$msg" "$func" "$@"
  else
    echo -n '   '"$msg"' (background)'

    # On Caldera 2.2, SIGHUP is sent to all our chilÐêdren when this script exits
    # I wanted to use shopt -u huponexit instead but their bash version
    # 1.14.7(1) is too old
 ”é   #
    # Ksh does not recognize the SIG prefix in front of a signal name
    (trap ''ßHUP; "$func" "$@") 2>&1 | logger -t 'VMwHé   #
    # Ksh does not recognize the SIG prefix in front of a signal name
    (trap '' HUP; "$func" "$@") 2>&1 | logger -t 'VMwHé   #
    # Ksh does not recognize the SIG prefix in front of a signal name
    (trap '' HUP; "$func" "$@") 2>&1 | logger -t 'VMwHèare[init]' -p daemon.err &

    vmware_success
    echo
    return 0
  fi
}

# Thisßis a function in case a future product name }èare[init]' -p daemon.err &

    vmware_success
    echo
    return 0
  fi
}

# This is a function in case a future product name }çcontains language-specific
# escape characters.
vmware_product_name() {
  echo 'VMware Tools'
  exit 0
}

# This is a function izæn case a future product contains language-specific
# escape characters.
vmware_roduct() {
  echo 'tools-for-linux'
  exit 0
}

9æn case a future product contains language-specific
# escape characters.
vmware_product() {
  echo 'tools-for-linux'
  exit 0
}

9åis_dsp()
{
   # This is the current way of indicating it is part of a
   # distribution-specific install.  Currently only applieäs to Tools.
   [ -e "$vmdb_answer_LIBDIR"/dsp ]
}

# They are a lot of smal“ utility programs to create temporary files in a
# s&äs to Tools.
   [ -e "$vmdb_answer_LIBDIR"/dsp ]
}

# They are a lot of small utility programs to create temporary files in a
# s&ãecure way, but none of them is standard. So I wrote this
make_tmp_dir() {
  local dirname="$1" # OUT
  local prefix="$2"  # IN
 Dâ local tmp
  local serial
  local loop

  tmp="${TMPDIR:-/tmp}"

  # Do‘'t overwrite existing user data
  # -> Create a director áy with a name that didn't exist before
  #
  # This may never succeed (if we are racing with a malicious process), but at
  # leKáy with a name that didn't exist before
  #
  # This may never succeed (if we are racing with a malicious process), but at
  # leKàast it is secure
  serial=0
  loop='yes'
  while [ "$loop" = 'yes' ¢; do
    # Check the validity of the temporary directory. WeÐ ß do this in the loop
    # because it can change over time
    if [ ! -d "$tmp" ]; then
      echo 'Error: "'"$tmp"'" is not a d ß do this in the loop
    # because it can change over time
    if [ ! -d "$tmp" ]; then
      echo 'Error: "'"$tmp"'" is not a d ß do this in the loop
    # because it can change over time
    –f [ ! -d "$tmp" ]; then
      echo 'Error: "'"$tmp"'" is not a d!Þirectory.'
      echo
      exit 1
    fi
    if [ ! -w "$tmp" -o ! -x "$tmp" ]; then
      echo 'Error: "'"$tmp"'" should be wr/!Þirectory.'
      echo
      exit 1
    fi
    if [ ! -w "$tmp" -o ! -x "$tmp" ]; then
      echo 'Error: "'"$tmp"'" should be wr/"Ýitable and executable.'
      echo
      exit 1
    fi

   ß# Be secure
    # -> Don't give write access to other users (so thate#Ü they can not use this
    # directory to launch a symlink attack)
    if mkdir -m 0755 "$tmp"'/'"$prefix$serial" >/dev/null 2>&"$Û1; then
      loop='no'
    else
      serial=`expr $serial + 1`
      serial_mod=`expr $serial % 200`
      if [ "$serial_mod" û%Ú= '0' ]; then
        echo 'Warning: The "'"$tmp"'" diršctory may be under attack.'
        echo
      fi
    fi
  done

  eval #&Ù"$dirname"'="$tmp"'"'"'/'"'"'"$prefix$serial"'
}

# Removes "stale" device node
# On udev-based systems, this is never needed.
#»'Ø On older systems, after an unclean shutdown, we might end up with
# a stale device node while the kernel driver has a new majorw'Ø On older systems, after an unclean shutdown, we mi˜ht end up with
# a stale device node while the kernel driver has a new majorw(×/minor.
vmware_rm_stale_node() {
   local node="$1"  # IN
   if [ -e "/dev/$node" -a "$node" != "" ]; then
      local node_majo)Ör=`ls -l "/dev/$node" | awk '{print \$5}' | sed -e s/,//`
      local node_minor=`ls -l "/dev/$node" | awk '{print \$6}'`
      à)Ör=`ls -l "/dev/$node" | awk '{print \$5}' | sedß-e s/,//`
      local node_minor=`ls -l "/dev/$node" | awk '{print \$6}'`
      à*Õif [ "$node_major" = "10" ]; then
         local real_minor=`cat /proc/misc | grep "$node" | awk '{print \$1}'`
         if [ "$þ+Ônode_minor" != "$real_minor" ]; then
            rm -f "/dev/$node"
         fi
      else
         local node_name=`echo $node •+Ônode_minor" != "$real_minor" ]; then
      ß     rm -f "/dev/$node"
         fi
      else
         local node_name=`echo $node •,Ó| sed -e s/[0-9]*$//`
         local real_major=`cat /proc/devices | grep "$node_name" | awk '{print \$1}'`
         if [ "$nodeÜ-Ò_major" != "$real_major" ]; then
            rm -f "/dev/$node"
         fi
      fi
   fi
}

# Checks if the given pid represenŽ.Ñts a live process.
# Returns 0 if the p–d is a live process, 1 otherwise
vmware_is_process_alive() {
   local pid="$1" # IN

   L/Ðps -p $pid | grep $pid > /dev/null 2>&1
}

# Check if the process associated to a pidfile is running.
# Return 0 if the pidfile Š0Ïexists and the process is running, 1 otherwise
vmware_check_pidfile() {
   local pidfile="$1" # IN
   local pid

   pid=`cat "$p˜1Îidfile" 2>/dev/null`
   if [ "$pid"ß= '' ]; then
      # The file probably does not exist or is empty. Failure
      return 1
  û2Í fi
   # Keep only the first number we find, because some Samba pid files are
   # really trashy: they end with NUL characters
 §3Ì  # There is no double quote around $pid on purpose
   set -- $pid
   pid="$1"

   vmware_is_process_alive $pid
}

# Note:
#  . Ù4ËEach daemon must be started fro’ its own directory to avoid busy devices
#  . Each PID file doesn't need to be added to the instl5Êaller database, because
#    it is going to be automatically removed when it becomes stale (after a
#    reboot). It must go dirc5Êaller database, because
#    it is going to be automatically removed when it becomes stale (after a
#    reboot). It must go dirc5Êaller database, because
#  ß it is going to be automatically removed when it becomes stale (after a
#    reboot). It must go dirc6Éectly under /var/run, or some distributions
#    (RedHat 6.0) won't clean it
#

# Terminate a process synchronously
vmware_synch6Éectly under /var/run, or some distributions
#    (RedHat 6.0) won't clean it
#

# Terminate a process synchronously
vmware_synch7Èrone_kill() {
   local id="$1"    # IN
   local signal="$2" # IN
   local second

   kill -"$signal" "$pid"

   # Wait a bit toé8Ç see if the dirty job has really been done
   for second in 0 1 2 3 4 5 6 7 8 9 10; do
      vmware_is_process_alive "$pid"
    Í9Æ  if [ "$?" -ne 0 ]; then
         # Success
         return 0
      fi

      sleep 1
   done

   # Timeout
   return 1
}

# Ki9Æ  if [ "$?" -ne 0 ]Ä then
         # Success
         return 0
      fi

      sleep 1
   done

   # Timeout
   return 1
}

# Ki:Åll the process associated to a pidfile
vmware_stop_pidfile() {
   local pidfile="$1" # IN
   local pid

   if [ ! -r "$pidfile"]–;Ä; then
      # Missing file. Success
      return 0
   fi

   pid=`cat "$pidfile" 2>/dev/null`
   if [ "$pid" = '' ]; then
     s<Ã # Empty file. ¬uccess
      return 0
   fi
   # Keep only the first number we find, because some Samba pid files are
   # reall=Ây trashy: they end with NUL characters
   # There is no double quote around $pid on purpose
   set -- $pid
   pid="$1"

   # Fir¬>Ást try a nice SIGTERM
   if vmware_synchrone_kill "$pid" 15; then
      return 0
   fi

   # Then send a strong SIGKILL
   if vm>Ást try a niœe SIGTERM
   if vmware_synchrone_kill "$pid" 15; then
      return 0
   fi

   # Then send a strong SIGKILL
   if vm?Àware_synchrone_kill "$pid" 9; then
      return 0
   fi

   return 1
}

# Determine if SELinux is enabled
isSELinuxEnabled() {
 Ú@¿  if [ "`getenforce 2> /dev/null`" = "Enforcing" ]; then
      echo "yes"
   else
      echo "no"
   fi
}

# Runs a command norm±@¿  if [ Ý`getenforce 2> /dev/null`" = "Enforcing" ]; then
      echo "yes"
   else
      echo "no"
   fi
}

# Runs a command norm±A¾ally if the SELinux is not enforced.
# Runs a command under the provided SELinux context if the context is passed.
# Runs a commÊB½and under the parent SELinux context first, then retry under
# the unconfined context if no context is passed.
vmware_exec_selin1C¼ux(Ö {
   local command="$1"
   local context="$2"

   if [ "`isSELinuxEnabled`" = 'no' ]; then
      # ignore the context paramC¼ux() {
   local command="$1"
   local context="$2"

   if [ "`isSELinuxEnabled`" = 'no' ]; then
      # ignore the context paramD»eter
      $command
      return $?
   fi

   # selinux is enforcing...
   if [ -z "$context" ]; then
      # context paramter iiEEs missing, try use the parent context
      $command
      retval=$?
      if [ $retval -eq 0 ]; then
	 return $retval
      fi
ÂF¹      # use the unconfined context
      context="unconfined_t"
   fi

   runcon -t $context -- $command
   return $?
}

# StartÍG¸ the blocking file system.  This consists of loading the module and
# mounting the file system.
vmware_start_vmblock() {
   mkd–{H·r -p -m 1777 /tmp/VMwareDnD

   # Try FUSE first, fall back on in-kernel module.
   vmware_start_vmblock_fuse && return 0

   vmTI¶ware_exec 'Loading module' vmware_load_module $vmblock
   exitcode=`expr $exitcode + $?`
   # Check to see if the file system isëJµ already mounted.
   if grep -q " $vmblockmntpt vmblock " /etc/mtab; then
       # If it is mounted, do nothing
       trueÄ
   æJµ already mounted.
   if grep -q " $vmblockmntpt vmblock " /etc/mtab; then
       # If it is mounted, do nothing
       true;
   æK´else
       # If it's not mounted, mount it
       vmware_exec_selinux "mount -t vmblock none $vmblockmntpt"
   fi
}

# Stop theÅK´else
       # If it's not mounted, mount it
       vmware_exec_selinux "mount -t vmblock none $vmblockmntpt"
   fi
}

#ßStop theÅL³ blocking file system
vmware_stop_vmblock() {
    # Check if the file system is mounted and only unmount if so.
    # Start withÁM² FUSE-based version first, then legacy one.
    #
    # Vmblock-fuse dev path could be /var/run/vmblock-fuse,
    # or /run/vmblöN±ock-fuse. Bug 758526.
    if grep -q "/run/vmblock-fuse fuse\.vmware-vmblock " /etc/mtab; then
       # if it's mou‘ted, then un!N±ock-fuse. Bug 758526.
    if grep -q "/run/vmblock-fuse fuse\.vmware-vmblock " /etc/mtab; then
       # if it's mounted, then un!Cþ#!/bin/sh
#
# Copyright (c) 1998-2017 VMware, Inc.  All rights reserved.
#
# This script manages the services needed to run VMwa§~